const fs = require('fs')
const path = require('path')

/**
 * Represents the number of common folder/file to go through before finding a `README.md`.
 * - apps/something/README.md -> 3
 *
 * If more than this, we use the difference to build the sub-README.md hierarchy.
 */
const ROOT_LEVEL = 3

/**
 * Format names following https://en.wikipedia.org/wiki/AP_Stylebook and https://en.wikipedia.org/wiki/APA_style styles
 */
const CONNECTIVES = 'a an and at but by for in nor of on or so the to up yet'
const UPPERCASE_WHITELIST = 'api css cms adr http nova sms ui rsk mms'

const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1)

const format = (str) => {
  if (!str) {
    return ''
  }

  const spaceSplit = /\s+/
  const wordSplit = /(\s+|[-‑–—])/

  return str
    .split(spaceSplit)
    .map((word) => {
      if (word === '-') {
        return word
      }

      if (word.includes('-')) {
        const items = word.split('-')

        if (items[0].length <= 2) {
          return word
        }

        return word.replace(/-/g, ' ')
      }

      return word
    })
    .join(' ')
    .split(wordSplit)
    .map((word, index, all) => {
      if (word.match(spaceSplit)) {
        return ' '
      }

      if (word.match(wordSplit)) {
        return word
      }

      if (UPPERCASE_WHITELIST.split(' ').includes(word.toLowerCase())) {
        return word.toUpperCase()
      }

      if (
        index !== 0 &&
        index !== all.length - 1 &&
        CONNECTIVES.split(' ').includes(word.toLowerCase())
      ) {
        return word.toLowerCase()
      }

      return capitalize(word)
    })
    .join('')
}

const updateAndReturnTitle = (lines) => {
  const index = lines.findIndex((line) => line.startsWith('# '))
  if (index === -1) {
    return null
  }
  const title = lines[index].slice(2)
  const formattedTitle = format(title)
  lines[index] = `# ${formattedTitle}`
  return formattedTitle
}

const updateAndReturnNavigationOverride = (lines) => {
  const navigationRegex = /^<!-- gitbook-navigation: "([^"]+)" -->$/
  const index = lines.findIndex((line) => line.match(navigationRegex))
  if (index === -1) {
    return null
  }
  const title = lines[index].match(navigationRegex)[1]
  const formattedTitle = format(title)
  lines[index] = `<!-- gitbook-navigation: "${formattedTitle}" -->`
  return formattedTitle
}

const printContent = (apps, libs, overview, repo, reference, misc) => {
  const formatDeep = (arr) =>
    arr
      .map(({ name, path, fromRoot }, index) => {
        const deep = fromRoot ? Array(fromRoot).fill(`  `).join('') : ``

        return `${deep}- [${name}](${path})${
          index === arr.length - 1 ? '' : '\n'
        }`
      })
      .join('')

  const formatRepository = repo
    .map(
      ({ name, path }, index) =>
        `- [${name}](${path})${index === repo.length - 1 ? '' : '\n'}`,
    )
    .join('')

  const formatMisc = misc
    .map(({ name, path }) => `- [${name}](${path})\n`)
    .join('')

  return `<!-- This file is automatically generated with \`yarn gitbook\` (scripts/gitbook.js), please do not modify this file directly -->

# Table of contents

- [Getting Started](README.md)

## Technical overview

${formatDeep(overview)}

## Repository

${formatRepository}

## Apps

${formatDeep(apps)}

## Libs

${formatDeep(libs)}

## Reference

${formatDeep(reference)}

## Misc

${formatMisc}`
}

const fromDir = async (startPath, res = [], readmeAsRoot = false) => {
  if (!fs.existsSync(startPath)) {
    return
  }

  const files = fs.readdirSync(startPath)

  // We move readme as first file of the array if it exists.
  const orderedFiles = [
    ...files.filter((name) => name.includes('README.md')),
    ...files.filter((name) => !name.includes('README.md')),
  ]

  for (const file in orderedFiles) {
    const filename = path.join(startPath, orderedFiles[file])
    const stat = fs.lstatSync(filename)

    if (stat.isDirectory()) {
      fromDir(filename, res, readmeAsRoot)
    } else if (/\.md$/.test(filename)) {
      const file = fs.readFileSync(filename, 'utf-8')
      const lines = file.split('\n')

      if (lines[0] === '<!-- gitbook-ignore -->') {
        return
      }

      // We overwrite the heading of the readme to match with our convention
      const title = updateAndReturnTitle(lines)
      const navigationTitle = updateAndReturnNavigationOverride(lines) ?? title

      if (!navigationTitle) {
        throw new Error(`Could not find a title in ${orderedFiles[file]}`)
      }

      const updatedFile = lines.join('\n')
      fs.writeFileSync(filename, updatedFile)

      const replaceWindowsBackslashes = filename.replace(/\\/g, '/')
      const deep = replaceWindowsBackslashes.split('/')
      const { length } = deep
      const level = length - ROOT_LEVEL

      const fromRoot =
        level > 0
          ? readmeAsRoot
            ? replaceWindowsBackslashes.includes('README.md')
              ? level - 1
              : level
            : level
          : undefined

      res.push({
        name: navigationTitle,
        path: replaceWindowsBackslashes,
        fromRoot,
      })
    }
  }

  return res
}

/**
 * This script creates a SUMMARY.md file used by GitBook to create its table of contents.
 *
 * We automatically get all *.md files in the different directories listed below.
 * We use the first line of the readme to define the name of the GitBook page.
 *
 * If a README.md is not worth being listed in GitBook, use `<!-- gitbook-ignore -->` on
 * the first line of the file.
 *
 * To run this script, do `yarn gitbook`
 */
const generateSummary = async () => {
  const [apps, libs, overview, repo, reference, misc] = await Promise.all([
    await fromDir('./apps'),
    await fromDir('./libs'),
    await fromDir('./handbook/technical-overview', [], true),
    await fromDir('./handbook/repository'),
    await fromDir('./handbook/reference', [], true),
    await fromDir('./handbook/misc'),
  ])

  fs.writeFileSync(
    'SUMMARY.md',
    printContent(apps, libs, overview, repo, reference, misc),
  )
}

const run = async () => {
  await generateSummary()
}

run()
